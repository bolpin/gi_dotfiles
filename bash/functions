# s() {
#   if [[ $PWD =~ /sign_in ]]; then
#     port=2000
#   elif [[ $PWD =~ /purchase ]]; then
#     port=3000
#   elif [[ $PWD =~ /asset_detail ]]; then
#     port=4000
#   elif [[ $PWD =~ /search ]]; then
#     port=5000
#   elif [[ $PWD =~ /collaboration ]]; then
#     port=7000
#   fi
#
#   app=$(shortpwd)
#   echo -e "\033]0;ðŸ’¡  ${app%/}  ðŸ’¡\007\r"
#   svcwatch=1 rails s -p $port
# }
#
# shortpwd()
# {
#   sp=$1
#   pwd="${PWD/$HOME/~}"
#   pwd="${pwd/~\/src\/unisporkal\/sign_in/ðŸ“$sp}"
#   pwd="${pwd/~\/src\/unisporkal\/purchase/ðŸ’°$sp}"
#   pwd="${pwd/~\/src\/unisporkal\/asset_detail/ðŸ“·$sp}"
#   pwd="${pwd/~\/src\/unisporkal\/search/ðŸ”Ž$sp}"
#   pwd="${pwd/~\/src\/unisporkal\/collaboration/ðŸ’—$sp}"
#   pwd="${pwd/~\/src\/unisporkal\/landing/ðŸ¡$sp}"
#   pwd="${pwd/~\/src\/unisporkal\/gems/ðŸ’Ž$sp}"
#   pwd="${pwd/ðŸ’Ž$sp\/unisporkal_engine/ðŸ’Ž$sp/ðŸš’$sp}"
#   pwd="${pwd/ðŸ’Ž$sp\/unisporkal_styles/ðŸ’Ž$sp/ðŸŽ¨$sp}"
#   pwd="${pwd/ðŸ’Ž$sp\/authentication/ðŸ’Ž$sp/ðŸ”$sp}"
#   pwd="${pwd/ðŸ’Ž$sp\/globalization/ðŸ’Ž$sp/ðŸ‡¬ðŸ‡§$sp}"
#   pwd="${pwd/ðŸ’Ž$sp\/sites/ðŸ’Ž$sp/ðŸŽ‘$sp}"
#   pwd="${pwd/~\/src\/unisporkal/ðŸ´$sp}"
#   pwd="${pwd/~\/src\/Newsmaker/ðŸ“°$sp}"
#   pwd="${pwd/~\/src\/MediaVast/ðŸŽµ$sp}"
#   echo "${pwd%/}/"
# }


# unipsorkal startup (run from a tmux session)
function uv { 
  tmux rename-session -s unisporkal
  tmux new-window -n unisporkal
  tmux send-keys 'u;cd search; rails s -p 5000' 'C-m'

  tmux split-window -h -p 50
  tmux send-keys 'u;cd asset_detail;rails s -p 4000' 'C-m'

  tmux split-window -v -p 50
  tmux send-keys 'u;cd sign_in;rails s -p 2000' 'C-m'
}

# Show most used commands in history:
function common_commands {
  history | awk '{a[$2]++}END{for(i in a){print a[i] " " i}}' | sort -rn | head -n 10
}

function common_git_commands {
  history | grep git | ruby -ane 'puts $F.drop(1).join(" ")'| awk '{a[$0]++}END{for(i in a){print a[i] " " i}}' | sort -rn | head -n 10
  # history | grep git | ruby -ane 'puts $F.drop(1).join(" ")'| ruby -e '$a = Hash.new(0); while gets; $a[$_] += 1 ;end; $a.each{|k,v| puts v.to_s + " " + k}' | sort -rn | head -n 10
}

# Creating a remote tracking branch
function gbt { 
  #git branch --track $2 $1/$2
  #git checkout $2
  git branch --track $1 "origin/$1"
  git checkout $1
}

function git-new-remote-tracking {
  git checkout -b $1 && git push -u origin $1
}


function take () { mkdir -p "$@" && eval cd "\"\$$#\""; }

# Allows commit message without typing quotes (can't have quotes in the commit msg though).
function gc {
  git commit -m "$*"
}



function rmf(){
  for file in $*
  do
    __rm_single_file $file
  done
}

function __rm_single_file(){
  if ! [ -d ~/.Trash/ ]
  then
    command /bin/mkdir ~/.Trash
  fi

  if ! [ $# -eq 1 ]
  then
    echo "__rm_single_file: 1 argument required but $# passed."
    exit
  fi

  if [ -e $1 ]
  then
    BASENAME=`basename $1`
    NAME=$BASENAME
    COUNT=0
    while [ -e ~/.Trash/$NAME ]
    do
      COUNT=$(($COUNT+1))
      NAME="$BASENAME.$COUNT"
    done

    command /bin/mv $1 ~/.Trash/$NAME
  else
    echo "No such file or directory: $file"
  fi
}


function remote_branch_info(){
  for k in `git branch -r | perl -pe 's/^..(.*?)( ->.*)?$/\1/'`
  do 
    echo -e `git show --pretty=format:"%Cgreen%ci %Cblue%cr %Cred%an %Creset" $k -- | head -n 1`\\t$k 
  done | sort -r
}

# Switch to a gem directory, trying to match your name the best
function cdgem {
  gem_dir=`gem env | grep INSTALLATION | cut -d' ' -f6`
  cd $gem_dir/gems
  cd `ls|grep $1|sort|tail -1`
}

function sgi {
  sudo gem install $1
}

function sagi {
  sudo apt-get -y install $1 
}

function syi {
  sudo yum -y install $1
}

function glg { 
  gem list | grep $1
}


function rrg { 
  bundle exec rake routes | grep $1
}


#################
#   git stuff   #
#################
git_sha() {
  git rev-parse --short HEAD 2>/dev/null
}

function git_branch_name {
  val=`git branch 2>/dev/null | grep '^*' | colrm 1 2`
  echo "$val"
}

function git-done {
  branch=`git_branch_name`
  git checkout master && git merge $branch --ff-only && bundle install && rake db:migrate db:test:prepare && rake && git push && git branch -D $branch && git push origin :$branch
}


function git-on-master {
  branch=`git_branch_name`
  git checkout master && git pull --rebase 
  git checkout $branch
  git rebase master
}


function parse_git_branch {
  val=`git_branch_name | sed 's_\(.*\)_(\1)_'`
  echo "$val"
}

function git-new-remote-tracking {
  git checkout -b $1 && git push -u origin $1
}

function git_done {
  branch=`git_branch_name`
  git checkout master && git pull --rebase 
  git checkout $branch && git rebase master && git checkout master && git merge $branch && bundle install && bundle exec rake db:migrate && bundle exec rake && git push && git branch -d $branch && git push origin :$branch
}

function git_nuke {
  git branch -D $1 && git push origin :$1
}

# Creating a remote tracking branch
function track { 
  git branch --track $1 "origin/$1"
}

function g {
  if [[ $# > 0 ]]; then
    git "$@"
  else
    git status --short
  fi
}
# compdef g=git

